#include <iostream>
#include <fstream>
#include <string>
#include "rocksdb/db.h"
#include "playbook.pb.h" // The generated header

int main() {
    // 1. Read the binary file generated by Java
    std::ifstream input("../../data/java_play.bin", std::ios::binary);
    if (!input) {
        std::cerr << "Error: Could not find java_play.bin. Did you run the Java Producer?" << std::endl;
        return 1;
    }

    // 2. Parse the bytes into a C++ LogEntry object
    registadb::LogEntry entry;
    if (!entry.ParseFromIstream(&input)) {
        std::cerr << "Failed to parse the Playbook message from Java." << std::endl;
        return 1;
    }

    std::cout << "C++ Received Message from Java!" << std::endl;
    std::cout << "ID: " << entry.id() << " | Content: " << entry.content() << std::endl;

    // 3. Open RocksDB
    rocksdb::DB* db;
    rocksdb::Options options;
    options.create_if_missing = true;
    rocksdb::Status status = rocksdb::DB::Open(options, "../../data/registadb_store", &db);

    if (!status.ok()) {
        std::cerr << "RocksDB connection failed: " << status.ToString() << std::endl;
        return 1;
    }

    // 4. Store the serialized data into RocksDB
    std::string serialized_data;
    entry.SerializeToString(&serialized_data);
    
    // We'll use the ID as the key
    std::string key = "entry_" + std::to_string(entry.id());
    status = db->Put(rocksdb::WriteOptions(), key, serialized_data);

    if (status.ok()) {
        std::cout << "Successfully committed Java message to RocksDB with key: " << key << std::endl;
    }

    delete db;
    return 0;
}